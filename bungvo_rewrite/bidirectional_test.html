<!DOCTYPE html>
<html>
<head>
    <title>Bungvo Bidirectional Scrolling Test</title>
    <style>
        body { margin: 0; padding: 20px; background: #333; }
        canvas { border: 2px solid #fff; }
        .controls { color: white; margin-top: 10px; }
        .status { color: yellow; font-weight: bold; }
    </style>
</head>
<body>
    <h2 style="color: white;">Bungvo Bidirectional Scrolling Test</h2>
    <canvas id="testCanvas" width="1000" height="400"></canvas>
    <div class="controls">
        <p><strong>Controls:</strong></p>
        <p>W/Up Arrow - Walk forward (world scrolls right to left)</p>
        <p>S/Down Arrow - Walk backward (world scrolls left to right)</p>
        <p>A/D or Left/Right - Move left/right</p>
        <p>Release keys - Stop walking (world stops)</p>
        <p class="status" id="status">Status: Standing still</p>
    </div>
    
    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        // Input handling
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);
        
        // Parallax layers
        const layers = [
            { name: 'sky', speed: 0.1, color: '#87CEEB', y: 0, height: 160, scrollX: 0 },
            { name: 'clouds', speed: 0.3, color: '#FFFFFF', y: 50, height: 30, scrollX: 0 },
            { name: 'background', speed: 0.5, color: '#B0C4DE', y: 100, height: 40, scrollX: 0 },
            { name: 'buildings', speed: 0.6, color: '#8B4513', y: 160, height: 120, scrollX: 0 },
            { name: 'fence', speed: 1.0, color: '#333333', y: 200, height: 80, scrollX: 0 },
            { name: 'sidewalk', speed: 1.0, color: '#808080', y: 340, height: 60, scrollX: 0 }
        ];
        
        const scrollSpeed = 100;
        let playerX = canvas.width * 0.3;
        
        function checkInput() {
            let isWalking = false;
            let walkDirection = 0;
            let moveDirection = 0;
            
            // Check movement keys
            if (keys['KeyW'] || keys['ArrowUp']) {
                isWalking = true;
                walkDirection = 1; // Forward
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                isWalking = true;
                walkDirection = -1; // Backward
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                moveDirection = -1;
                isWalking = true;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                moveDirection = 1;
                isWalking = true;
            }
            
            // Update player position (limited horizontal movement)
            if (moveDirection !== 0) {
                playerX += moveDirection * 50 * 0.016;
                playerX = Math.max(100, Math.min(canvas.width - 100, playerX));
            }
            
            return { isWalking, walkDirection };
        }
        
        function animate() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Check if player is walking
            const playerState = checkInput();
            
            // Update status
            if (playerState.isWalking) {
                if (playerState.walkDirection > 0) {
                    statusEl.textContent = 'Status: Walking forward (world scrolling ‚Üê)';
                } else if (playerState.walkDirection < 0) {
                    statusEl.textContent = 'Status: Walking backward (world scrolling ‚Üí)';
                } else {
                    statusEl.textContent = 'Status: Moving sideways';
                }
            } else {
                statusEl.textContent = 'Status: Standing still (world stopped)';
            }
            
            // Only scroll when walking
            if (playerState.isWalking && playerState.walkDirection !== 0) {
                layers.forEach(layer => {
                    layer.scrollX += scrollSpeed * layer.speed * 0.016 * playerState.walkDirection;
                    
                    // Handle wrapping for both directions
                    const mirroring = 400;
                    if (layer.scrollX >= mirroring) {
                        layer.scrollX -= mirroring;
                    } else if (layer.scrollX < 0) {
                        layer.scrollX += mirroring;
                    }
                });
            }
            
            // Render parallax layers
            layers.forEach(layer => {
                const tileWidth = 200;
                let startX;
                
                if (layer.name === 'sidewalk') {
                    // Special rendering for sidewalk with cracks
                    ctx.fillStyle = layer.color;
                    ctx.fillRect(0, layer.y, canvas.width, layer.height);
                    
                    // Scrolling cracks
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 1;
                    const crackSpacing = 100;
                    startX = -layer.scrollX % crackSpacing;
                    for (let x = startX; x < canvas.width + crackSpacing; x += crackSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(x, layer.y);
                        ctx.lineTo(x, layer.y + layer.height);
                        ctx.stroke();
                    }
                } else {
                    // Regular layer rendering
                    startX = -layer.scrollX % tileWidth;
                    ctx.fillStyle = layer.color;
                    
                    for (let x = startX; x < canvas.width + tileWidth; x += tileWidth) {
                        ctx.fillRect(x, layer.y, tileWidth - 2, layer.height);
                    }
                }
                
                // Layer label
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`${layer.name} (${layer.speed}x)`, 10, layer.y + 15);
            });
            
            // Player
            ctx.fillStyle = playerState.isWalking ? '#FFD700' : '#d4af37';
            ctx.fillRect(playerX, 280, 40, 60);
            
            // Instructions
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText('üö∂ BIDIRECTIONAL SCROLLING', 10, 30);
            ctx.fillText('W/S = Forward/Backward, A/D = Left/Right', 10, 50);
            
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>